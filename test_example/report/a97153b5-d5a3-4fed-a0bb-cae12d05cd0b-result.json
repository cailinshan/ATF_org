{"fullName": "test_mail#test_asiainfo", "status": "broken", "start": 1582683767748, "historyId": "7afa2a8465e4c36b566351a8ac8635cf", "stop": 1582683788784, "labels": [{"value": "test_mail", "name": "suite"}, {"value": "PC-20160717KIMX", "name": "host"}, {"value": "8844-MainThread", "name": "thread"}, {"value": "pytest", "name": "framework"}, {"value": "cpython3", "name": "language"}, {"value": "test_mail", "name": "package"}], "uuid": "f29ed46f-1814-49a7-801e-490cb52577f0", "testCaseId": "59d4b391527904295644ed8fec116511", "name": "test_asiainfo", "statusDetails": {"trace": "def test_asiainfo():\n>       rst = mailCon.connect_mail('asiainfo.com', 'caixg')\n\ntest_mail.py:16: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\utils\\mailCon.py:9: in connect_mail\n    clint = imaplib.IMAP4(sendserver)\nd:\\anaconda3\\lib\\imaplib.py:189: in __init__\n    self.open(host, port)\nd:\\anaconda3\\lib\\imaplib.py:286: in open\n    self.sock = self._create_socket()\nd:\\anaconda3\\lib\\imaplib.py:276: in _create_socket\n    return socket.create_connection((self.host, self.port))\nd:\\anaconda3\\lib\\socket.py:712: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('mail.asiainfo.com', 143), timeout = <object object at 0x000000000016F150>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               TimeoutError: [WinError 10060] 由于连接方在一段时间后没有正确答复或连接的主机没有反应，连接尝试失败。\n\nd:\\anaconda3\\lib\\socket.py:703: TimeoutError", "message": "TimeoutError: [WinError 10060] 由于连接方在一段时间后没有正确答复或连接的主机没有反应，连接尝试失败。"}}